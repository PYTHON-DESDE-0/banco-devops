{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Banco","text":"<p>Esta p\u00e1gina incorpora la documentaci\u00f3n  acerca del presente proyecto.</p> <p>S\u00f3lo deploy</p> <p>(Por el momento, solo se incluye informaci\u00f3n acerca del despliegue del proyecto.)</p>"},{"location":"#despliegue","title":"Despliegue","text":"<p>En esta secci\u00f3n se analizan los criterios para  la puesta en marcha del sistema,  pensando espec\u00edficamente en el uso de contenedores usando gestores como Docker y Podman.</p> <p>Comenzar</p>"},{"location":"consideraciones/","title":"Consideraciones de dise\u00f1o","text":""},{"location":"consideraciones/#arquitectura-de-servicios","title":"Arquitectura de servicios","text":"<p>A\u00fan no establecida de manera definitiva. En principio ser\u00edan tres servicios monol\u00edticos:</p> <ul> <li>Un servicio de frontend;</li> <li>Un servicio de backend;</li> <li>Un servicio de SQL;</li> </ul> <p>La regla b\u00e1sica de asignaci\u00f3n ser\u00eda: un servicio - un contenedor.</p>"},{"location":"consideraciones/#componentes","title":"Componentes","text":""},{"location":"consideraciones/#frontend-flet","title":"Frontend - FLET","text":"<p>Flet es un framework apto tanto para crear tanto apps multiplataforma (Android, IOS, Windows, Linux)  como tambi\u00e9n p\u00e1ginas web  tanto est\u00e1ticas como din\u00e1micas. Es fork del popular framework Flutter  y est\u00e1 adaptado al lenguaje Python.</p>"},{"location":"consideraciones/#backend-fastapi-test","title":"Backend - FastAPI (test)","text":"<p>FastAPI es un potente framework para crear servidores backend basado en Flask. Trae integrados los servidores Uvicorn y Guvicorn,  los cuales ya traen mecanismos integrados para la gesti\u00f3n paralela  de las peticiones remotas. Se escribe en Python.</p>"},{"location":"consideraciones/#sql-postgresql","title":"SQL - PostgreSQL","text":"<p>PostgreSQL es uno de los gestores de bases de datos m\u00e1s populares y potentes Es de c\u00f3digo abierto y destaca el manejo de bases de datos grandes.  Hay m\u00faltiples servicios online que ofrecen su despliegue.</p>"},{"location":"consideraciones/#despliegue-deploy","title":"Despliegue (deploy)","text":""},{"location":"consideraciones/#modo-manual","title":"Modo manual","text":"<p>El despliegue se puede realizar de manera manual (database en un servidor, backend en otro, etc.) aprovechando servicios online dedicados.</p>"},{"location":"consideraciones/#gestores-de-contenedores-docker-y-podman","title":"Gestores de contenedores - Docker y Podman","text":"<p>Se piensa en el posible despliegue del sistema completo tanto en servidores como en equipos de desarrollo con la ayuda de gestores de contenedores, donde el m\u00e1s popular es Docker.  La alternativa inmediata es Podman,  el cual es altamente compatible con las im\u00e1genes de Docker  y tiene una sintaxis casi id\u00e9ntica.</p> <p>El despliegue completo se configura con bastante facilidad con los archivos <code>compose</code>. los cuales permiten tambi\u00e9n hacer contenedores paralelos para un mejor reparto de carga de CPU, lo cual da cierto margen de escalabilidad.</p>"},{"location":"consideraciones/#orquestadores-de-contenedores-kubernetes","title":"Orquestadores de contenedores - Kubernetes","text":"<p>Es posible pensar a futuro en el despliegue con orquestadores de contenedores como Kubernetes con ayuda de sus manifiestos. Sin embargo, debe se\u00f1alarse que:</p> <ul> <li>Kubernetes es considerado como sobreingenier\u00eda para sistemas peque\u00f1os y medianos:  no se justifica para varias miles de peticiones por segundo.</li> <li>Kubernetes y sus implementaciones para uso en PC (K3S, Minikube, KinD) son bastante m\u00e1s exigentes en recursos de base que Docker o Podman. </li> <li>Los manifiestos de Kubernetes tambi\u00e9n tienen sus propias reglas y complejidades.</li> </ul>"},{"location":"borradores/adicionales/","title":"Componentes adicionales","text":""},{"location":"borradores/adicionales/#nginx","title":"NGINX","text":"<p>Este mini servidor web sirve para varios cometidos: - Load balancer: repartir el tr\u00e1fico de entrada entre varios servicios del sistema iguales - Servidor SSH-&gt; posiblemente necesario para servidores HTTPS - Control Ingress: reparte las peticiones de entrada entre los distintos servicios componentes dek sistema.</p>"},{"location":"borradores/adicionales/#logs-auditoria","title":"Logs (Auditor\u00eda)","text":"<p>Es importante crear un sistema para registrar los eventos internos, ya sean estos normales o an\u00f3malos</p> <ul> <li>logs locales:  pueden ser muy voluminosos. Consumen parte del hsoting Exigir\u00edan un volumen dedicado para ellos.</li> <li>logs remotos</li> </ul>"},{"location":"borradores/adicionales/#monitoreo","title":"Monitoreo","text":"<p>Hay servicios externos que monitorean el estado de los servicios internos del sistema.</p>"},{"location":"borradores/adicionales/#documentacion","title":"Documentaci\u00f3n","text":"<p>Se podr\u00eda crear un repositorio unificado con toda la documentaci\u00f3n del proyecto. Si bien GitHub permite leer los documentos Markdown en directo, opciones como MkDocs o Hugo pueden mejorar notablemente la experiencia de usuario.</p>"},{"location":"borradores/entorno/","title":"SQLMODEL + ENTORNO","text":"<p>Apuntes r\u00e1pidos del test</p>"},{"location":"borradores/entorno/#entorno","title":"Entorno","text":""},{"location":"borradores/entorno/#archivo-de-entorno","title":"Archivo de entorno","text":"<p>Archivo<code>db.env</code>: <pre><code>POSTGRES_PASSWORD=123456\nPOSTGRES_USER=postgres\nPOSTGRES_DB=test-db\n</code></pre></p>"},{"location":"borradores/entorno/#carga-en-bash","title":"Carga en Bash","text":"<p>Cargar variables de entorno en Bash desde el archivo<code>db.env</code>:</p> <pre><code>set -o allexport; source db.env; set +o allexport\n</code></pre> <p>https://www.returngis.net/2023/10/cargar-variables-de-entorno-en-un-script-bash-desde-un-env-con-set-allexport/</p>"},{"location":"borradores/entorno/#sqlmodel","title":"SQLModel","text":""},{"location":"borradores/entorno/#anfitrion","title":"anfitrion","text":"<p>En caso de usar la rutina de SQLModel desde el equipo anfitrion el dominio de la base de datos ser\u00e1 <code>localhost</code>. <pre><code>export DOMINIO_POSTGRES=localhost \n</code></pre> Tambi\u00e9n se permite usar la IP comod\u00edn <code>0.0.0.0</code></p> <p>De esta forma la petici\u00f3n a la base de datos se har\u00e1 a una URL como esta:</p> <pre><code>postgresql://&lt;user&gt;:&lt;pass&gt;w@localhost:&lt;numero_puerto&gt;/test-db\n</code></pre>"},{"location":"borradores/entorno/#contenedor","title":"contenedor","text":"<p>Si la rutina de SQLModel funciona en un contenedor  integrado dentro del archivo Compose el dominio indicado ser\u00e1  el nombre de servicio del contenedor de la base de datos:</p> <pre><code>export DOMINIO_POSTGRES=&lt;servicio_postgres&gt;\n</code></pre> <p>y la petici\u00f3n a la base de datos se har\u00e1 a una URL as\u00ed:</p> <pre><code>postgresql://&lt;user&gt;:&lt;pass&gt;w@&lt;servicio_postgres&gt;:&lt;numero_puerto&gt;/test-db\n</code></pre> <p>El nombre de servicio es elegido por el desarrollador adentro del archivo Compose.</p> <p>IMPORTANTE:</p> <p>Docker utiliza el archivo Compose para simular una red privada de contenedores, en analog\u00eda a las redes privadas de computadoras f\u00edsicas.</p> <p>En este contexto,  el \"nombre de servicio\" se ve como un alias asignado al contenedor pero es en realida un alias para la IP interna del contenedor dentro de la red privada clase A.</p> <p>Resolver problemas de conexi\u00f3n con PostgreSQL: https://dev.to/deni_sugiarto_1a01ad7c3fb/fixing-connection-refused-error-between-pgadmin-and-postgres-in-docker-14ge</p>"},{"location":"borradores/flet/","title":"Flet","text":""},{"location":"borradores/flet/#servidorescomandos","title":"Servidores/comandos","text":""},{"location":"borradores/flet/#flet_1","title":"Flet","text":"<p>Da soporte para web. Es MUY lento</p> <pre><code>flet run  main.py --web --port 8000\n# MUY LENTO\n</code></pre> <pre><code>CMD [\"flet\", \"run\", \"src/main.py\",\"--web\", \"--port\", \"8000\"]  \n</code></pre>"},{"location":"borradores/flet/#uvicorn","title":"Uvicorn","text":"<p>Cambiar la l\u00ednea de llamado al int\u00e9rprete:</p> <p><pre><code># archivo 'main.py'\nft.app(main)\n</code></pre> por:</p> <pre><code># archivo 'main.py'\napp = ft.app(main, export_asgi_app=True)\n</code></pre> <p>Entonces llamar al servidor uvicorn:</p> <pre><code>uvicorn main:app --port 8000    \n# BIEN    \nuvicorn main:app --port 8000  --host 0.0.0.0\n# ???\n</code></pre> <p>En caso de usar contenedores, hacer:</p> <pre><code>CMD [\"uvicorn\", \"src.main:app\", \"--port\", \"8000\", \"--host\", \"0.0.0.0\"]\n# BIEN !!!\n</code></pre> <p>Para usar containers, agregar  <code>--host 0.0.0.0</code>  para que el gestor de contenedores permita conexiones desde afuera.</p> <p>https://docker-fastapi-projects.readthedocs.io/en/latest/uvicorn.html</p>"},{"location":"borradores/flet/#hypercorn","title":"Hypercorn","text":"<p>https://github.com/pgjones/hypercorn/</p> <p>Requiere instalacion</p> <pre><code>pip install hypercorn\n</code></pre> <pre><code>hypercorn main:app --bind 0.0.0.0:8000\n# BIEN\n</code></pre> <pre><code>CMD [\"hypercorn\", \"src.main:app\", \"--bind\", \"8000:0.0.0.0\"]\n# MAL\n</code></pre>"},{"location":"borradores/flet_app/","title":"Flet app","text":"<p>Flet app using Flet extension.</p> <p>To run the app:</p> <ol> <li>Install dependencies from pyproject.toml:</li> </ol> <pre><code>poetry install\n</code></pre> <ol> <li>Build app:</li> </ol> <pre><code>poetry run flet build macos -v\n</code></pre> <ol> <li>Run app:</li> </ol> <pre><code>poetry run flet run\n</code></pre>"},{"location":"borradores/mkdocs/","title":"MkDocs","text":""},{"location":"borradores/mkdocs/#instalacion","title":"Instalaci\u00f3n","text":"<pre><code>pip install mkdocs-material\n</code></pre>"},{"location":"borradores/mkdocs/#nuevo-proyecto","title":"Nuevo proyecto","text":"<pre><code>mkdocs new .\n</code></pre> <p>Crea una carpeta <code>docs</code> con un archivo demo y un archivo de configuraci\u00f3n llamado <code>mkdocs.yml</code>.</p>"},{"location":"borradores/mkdocs/#servidor-local","title":"Servidor local","text":"<pre><code>mkdocs serve\nmkdocs serve -a localhost:numero_puerto\n</code></pre>"},{"location":"borradores/mkdocs/#contenedores","title":"Contenedores","text":""},{"location":"borradores/mkdocs/#crear-imagen-manual","title":"Crear imagen (manual)","text":"<pre><code>podman build  -t imagen-mkdocs  .\n</code></pre>"},{"location":"borradores/mkdocs/#crear-contenedor-manual","title":"Crear contenedor (manual)","text":"<pre><code>podman build  -t imagen-mkdocs  .\n</code></pre>"},{"location":"borradores/servidores/","title":"Servidores Python","text":""},{"location":"borradores/servidores/#wsgi","title":"WSGI","text":"<p>WSGI es el Python Web Server Gateway</p> <p>No es compatible con protocolos web agregados como WebSockets.</p> <p>https://peps.python.org/pep-3333/</p>"},{"location":"borradores/servidores/#asgi","title":"ASGI","text":"<p>ASGI (Asynchronous Server Gateway Interface) es una version superadora de WSGI.</p> <p>https://asgi.readthedocs.io/en/latest/</p>"},{"location":"borradores/servidores/#uvicorn","title":"Uvicorn","text":"<p>Uvicorn es un servidor ASGI implementado en Python.</p> <p>Soporta HTTP, HTTP/1.1, HTTP/2 y WebSockets</p> <p>https://www.uvicorn.org</p> <p>https://jblazquez.es/dockerizando-tu-aplicacion-flask-con-gunicorn-un-paso-clave-para-el-despliegue-exitoso/</p>"},{"location":"borradores/servidores/#gunicorn","title":"Gunicorn","text":"<p>Gunicorn es un servidor WSGI implementado en Python</p> <p>https://docs.gunicorn.org/en/stable/</p>"},{"location":"borradores/tips/","title":"Tips","text":""},{"location":"borradores/tips/#python","title":"Python","text":""},{"location":"borradores/tips/#imagenes-oficiales","title":"Im\u00e1genes oficiales","text":"<p>Im\u00e1genes oficiales de Python disponibles en DockerHub:</p> <p>DockerHub - Python Images</p>"},{"location":"borradores/tips/#fastapi","title":"FastAPI","text":"<p>Basado en el tutorial oficial</p>"},{"location":"borradores/tips/#proxys","title":"Proxys","text":"<p>Si se usa un proxy como NGINX o Traefik hay que agregar la opci\u00f3n <code>--proxy-headers</code> al <code>CMD</code> del Dockerfile:</p> <pre><code># If running behind a proxy like Nginx or Traefik add --proxy-headers\nCMD [\"fastapi\", \"run\", \"app/main.py\", \"--port\", \"80\", \"--proxy-headers\"]\n</code></pre> <p>https://www.restack.io/p/fastapi-answer-docker-setup</p>"},{"location":"borradores/tips/#comandos-en-archivo-compose","title":"Comandos en archivo compose","text":"<p>Si se usa el docker-compose, tambi\u00e9n se puede llamar al comando uvicorn:</p> <pre><code>version: '3'\n\nservices:\nweb:\n    build: .\n    command: sh -c \"uvicorn main:app --reload --port=8000 --host=0.0.0.0\"\n    ports:\n    - 8000:8000\n</code></pre> <p>https://dev.to/rajeshj3/dockerize-fastapi-project-like-a-pro-step-by-step-tutorial-7i8</p>"},{"location":"borradores/tips/#paralelizacion","title":"Paralelizaci\u00f3n:","text":"<p>Multiples \"workers\" (contenedores) en Docker/Kubernetes corriendo <code>fastapi</code> o <code>uvicorn</code></p> <p>https://fastapi.tiangolo.com/deployment/server-workers/?h=dock#deployment-concepts</p>"},{"location":"borradores/tips/#lifespan-events","title":"Lifespan events","text":"<p>Es c\u00f3digo que se ejecuta solamente una vez antes de arrancar el servidor.</p> <p>Se requiere que el Dockerfile use la instrucci\u00f3n <code>CMD</code> en la forma \"exec\": <pre><code>CMD [\"fastapi\", \"run\", \"app/main.py\", \"--port\", \"80\"]\n</code></pre> Yno en la forma \"shell\":</p> <pre><code>CMD fastapi run app/main.py --port 80\n</code></pre> <p>FastAPI - Lifespan events</p>"},{"location":"borradores/tips/#cliente-fastapi-vs-uvicorn-vs-gunicorn","title":"Cliente Fastapi vs Uvicorn vs Gunicorn","text":"<pre><code>????\n\n[Ver sobre los servidores de Python](servidores.md)\n</code></pre>"},{"location":"borradores/tips/#incompatibilidades","title":"Incompatibilidades","text":"<p>WARNING: de momento, FastAPI parece no ser compatible con Python 3.14</p> <p>Algunas im\u00e1genes base compatibles:</p> <pre><code>python:3.13.1-bookworm\n\npython:3.9\npython:3.9.21-alpine3.21\npython:3.9.21-slim-bullseye    \npython:3.9.21-bullseye      \n</code></pre>"},{"location":"borradores/tips/#conexion-con-sql","title":"Conexion con SQL","text":""},{"location":"borradores/tips/#-sqlalchemy","title":"- SQLAlchemy","text":"<p>Uno de los ORMs m\u00e1s conocidos escritos para Python.</p> <p>P\u00e1gina oficial de  SQLAlchemy</p>"},{"location":"borradores/tips/#-sqlmodel","title":"- SQLModel","text":"<p>Del creador de FastAPI,  SQLModel es un conector de bases de datos basado en SQLAlchemy e incluye tipado heredado de Pydantic. </p> <p>Est\u00e1 pensado para facilitar la conexi\u00f3n de bases de datos con los servidores implementados con FastAPI.</p> <p>SQLModel - P\u00e1gina oficial</p> <p>SQLModel - testing</p>"},{"location":"borradores/tips/#extras","title":"Extras:","text":"<ul> <li> <p>CodevoWeb - Acceso y tokens</p> </li> <li> <p>CodevoWeb - Emails </p> </li> <li> <p>CodevoWeb - RESTful API con PostgreSQL</p> </li> </ul>"},{"location":"borradores/tips/#flet","title":"FLET","text":"<p>Fly.io</p>"},{"location":"borradores/tips/#instalacion","title":"Instalaci\u00f3n:","text":"<pre><code>pip install flet        # minima\npip install flet[all]   # completa\n</code></pre>"},{"location":"borradores/tips/#crear-proyecto-desde-plantilla","title":"Crear proyecto desde plantilla","text":"<p>Crea una app de un contador: <pre><code>flet create\n</code></pre> Incluye archivos de configuracion:</p> <p>flet.dev - Create a new Flet app</p>"},{"location":"borradores/tips/#ejecucion","title":"Ejecuci\u00f3n","text":"<p>Servidor web, puerto random: <pre><code>flet run --web app.py\n</code></pre></p> <p>Servidor, puerto espec\u00edfico: <pre><code>flet run --web --port 8000 app.py\n</code></pre></p> <p>Flet.dev - Host app as a dynamic website</p>"},{"location":"borradores/tips/#self-hosting-servidor-dinamico","title":"Self-hosting (servidor din\u00e1mico):","text":"<ul> <li> <p>App demo;</p> </li> <li> <p>Como hacer un proxy con NGINX: configurar <code>/etc/nginx/sites-available/*</code> </p> </li> </ul> <p>Flet.dev - Self Hosting</p>"},{"location":"borradores/tips/#crear-sitio-estatico","title":"Crear sitio est\u00e1tico:","text":"<p>Construir sitio web (descarga Flutter): </p> <p><pre><code>flet build web\nflet publish\n</code></pre> Este crea una subcarpeta <code>build</code> con necesarios:</p> <ul> <li>La carpeta <code>web</code> con todos los contenidos del sitio web creado;</li> <li>El int\u00e9rprete de Flutter. </li> </ul> <p>Puesta en funcionamiento:</p> <pre><code>python -m http.server --directory build/web\n</code></pre> <p>Flet.dev - Publish app to a static website</p>"},{"location":"borradores/tips/#crear-apps-con-flet","title":"Crear apps con Flet","text":"<p>Las instrucciones exactas var\u00edan con el sistema operativo destino.</p> <p>Flet.dev - Publishing Flet app to multiple platforms</p>"},{"location":"componentes/","title":"Componentes de Software","text":""},{"location":"componentes/#introduccion","title":"Introducci\u00f3n","text":"<p>En esta secci\u00f3n se discuten los frameworks y paquetes utilizados, haciendo hincapi\u00e9 en su instalaci\u00f3n y uso desde el sistema anfitri\u00f3n.</p>"},{"location":"componentes/entorno/","title":"Variables de entorno","text":"<p>Las variables de entorno son variables que maneja la terminal (la shell) para el proceso que corre  y que comparte con los procesos que invoca.</p>"},{"location":"componentes/entorno/#variables-en-bash","title":"Variables en Bash","text":"<p>En este art\u00edculo se asume el uso de la terminal Bash para todos los comandos.</p>"},{"location":"componentes/entorno/#asignacion-manual","title":"Asignaci\u00f3n manual","text":"<p>La creaci\u00f3n de estas variables se realiza con el comando <code>export</code>:</p> <p><pre><code>export MI_VARIABLE=25\n</code></pre> La costumbre es escribir los nombres de las variables de entorno en may\u00fasculas.</p> <p>Los valores son modificables a posteriori con una simple asignaci\u00f3n:</p> <pre><code>MI_VARIABLE=\"hola, que tal\"\n</code></pre>"},{"location":"componentes/entorno/#consulta","title":"Consulta","text":"<p>Los valores se consultan con el comando <code>echo</code>:</p> <pre><code>echo $MI_VARIABLE\n</code></pre> <p>Si la variable es inexistente entonces no se muestra nada.</p>"},{"location":"componentes/entorno/#archivos-de-entorno","title":"Archivos de entorno","text":"<p>Las variables de entorno se suelen guardar en archivos con el nombre <code>.env</code> (oculto) o en archivos con extensi\u00f3n <code>.env</code>.</p>"},{"location":"componentes/entorno/#sintaxis","title":"Sintaxis","text":"<p>Las variables se guardan en formato texto como asignaciones.</p> <p>Ejemplo: un archivo llamado <code>variables.env</code>:</p> <pre><code>USER=soy_yo\nPASSWORD=123456\n</code></pre> <p>gitignore</p> <p>Es importante agregar los archivos <code>.env</code> al archivo <code>.gitignore</code>  para prevenir el guardado de los valores de las variables de entorno sensibles en el repositorio de Git.</p> <pre><code>.env\n*.env\n</code></pre>"},{"location":"componentes/entorno/#lectura","title":"Lectura","text":"<p>La carga de los valores se hace con los siguientes comandos:</p> <p><pre><code>set -o allexport        \nsource variables.env       \nset +o allexport    \n</code></pre> o:</p> <pre><code>set -o allexport; source variables.env; set +o allexport    \n</code></pre> <p>Explicaci\u00f3n:</p> <ul> <li><code>set -o allexport</code> habilita que los subprocesos de la actual shell  puedan recibir los valores de las variables;</li> <li><code>source variables.env</code> lee las variables y sus desde el archivo;</li> <li><code>set +o allexport</code> \"desacopla\" a los subprocesos ante posibles cambios de valor de estas variables.</li> </ul>"},{"location":"componentes/entorno/#referencias","title":"Referencias","text":"<p>Returngis.net - Cargar variables de entorno en un script Bash</p>"},{"location":"componentes/sqlmodel/","title":"SQLModel","text":"<p>SQLModel es un conector de bases de datos basado en SQLAlchemy e incluye tipado heredado de Pydantic.</p> <p>Est\u00e1 pensado para facilitar la conexi\u00f3n de bases de datos con los servidores implementados con FastAPI. (De hecho este conector fue creado por el mismo creador de FastAPI ).</p> <p>P\u00e1gina oficial de SQLModel</p>"},{"location":"componentes/sqlmodel/#instalacion","title":"Instalaci\u00f3n","text":"<p>El paquete se instala desde PIP:</p> <pre><code>pip install sqlmodel\n</code></pre> <p>Para poder interaccionar con bases de datos PostgreSQL se necesita un paquete adicional llamado <code>psycopg2-binary</code>:</p> <pre><code>pip install psycopg2-binary\n</code></pre>"},{"location":"componentes/sqlmodel/#demo","title":"Demo","text":"<p>En la p\u00e1gina oficial de SQLModel se proporcionan demos para interaccionar con bases SQLite, las cuales se basan en archivos locales.</p> <p>Este es el c\u00f3digo:</p> <pre><code>from typing import Optional\nfrom sqlmodel import Field, Session, SQLModel, create_engine\n\n# Nueva tabla como clase\nclass Hero(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    name: str\n    secret_name: str\n    age: Optional[int] = None\n\n# Nuevos registros (\"filas\" de la tabla) como atributos\nhero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\")\nhero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\")\nhero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48)\n\n# ruta al archivo SQLite\nsqlite_file_name = \"database.db\"  \nsqlite_url = f\"sqlite:///{sqlite_file_name}\"  \n\n# creaci\u00f3n del conector\nengine = create_engine(\n    sqlite_url,     # URL a la base de datos\n    echo=True       # log por consola\n    )  \n\nSQLModel.metadata.create_all(engine)\n\n# transacci\u00f3n con el archivo\nwith Session(engine) as session:\n    session.add(hero_1)\n    session.add(hero_2)\n    session.add(hero_3)\n    session.commit()\n</code></pre> <p>Este c\u00f3digo crea una nueva tabla en la base de datos llamada <code>hero</code> y le asigna tres filas con los datos indicados:</p> id name secret_name age 1 Deadpond Dive Wilson 2 Spider-Boy Pedro Parqueador 3 Rusty-Man Tommy Sharp 48 <p>Si la tabla ya existe, entonces se agregan las tres nuevas filas al final.</p>"},{"location":"componentes/sqlmodel/#consultas-queries","title":"Consultas (queries)","text":""},{"location":"componentes/sqlmodel/#sqlite","title":"SQLite","text":"<p>SQLite trabaja con archivos locales con extensi\u00f3n <code>.db</code>, los cuales no incluyen autenticaci\u00f3n ni permiso alguno. La URL requerida para la consulta se reduce</p> <pre><code>sqlite:///ruta_archivo\n</code></pre> <p>Si el archivo no se encuentra en la ruta indicada entonces este se crea.</p>"},{"location":"componentes/sqlmodel/#gestores-de-bases-de-datos","title":"Gestores de bases de datos","text":"<p>La mayor\u00eda de los gestores de bases de datos implementan un servidor para consultar la base de datos. La URL debe incluir toda la informaci\u00f3n necesaria para la conexi\u00f3n, incluyendo el nombre del driver requerido.</p> <p>En el caso de tener un servidor PostgreSQL la petici\u00f3n queda como:</p> <pre><code>postgresql://usuario:contrase\u00f1a@dominio:puerto/nombre_database\n</code></pre> <p>Por ejemplo, una conexi\u00f3n t\u00edpica en el equipo local  y con el puerto predeterminado ser\u00eda:</p> <pre><code>postgresql://postgres:123456@localhost:5432/test-db\n</code></pre> <p>y la URL as\u00ed conformada se usa para crear el conector:</p> <pre><code>engine = create_engine(\n    postgres_url,       # URL a la base de datos\n    echo=True           # log por consola (opcional)\n    )\n</code></pre> <p>URL con psycopg2</p> <p>En las peticiones a veces se les indica el uso de <code>psycopg2</code>:</p> <pre><code>postgresql+psycopg2://usuario:contrase\u00f1a@dominio:puerto/nombre_database\n</code></pre>"},{"location":"componentes/sqlmodel/#variables-de-entorno","title":"Variables de entorno","text":"<p>La rutina de Python  se adapta para poder configurar la URL. Los par\u00e1metros requeridos: dominio, puerto, usuario, contrase\u00f1a, etc. son pasados con ayuda de variables de entorno precargadas en la shell:</p> <p><pre><code>import os\n\n# Lectura de variables de entorno - con valores predefinidos\nuser     = os.getenv(\"USUARIO_POSTGRES\" , default='postgres')\npassword = os.getenv(\"PASSW_POSTGRES\"   , default='123456'  )\n# ...\n</code></pre> La funci\u00f3n <code>getenv()</code> del m\u00f3dulo <code>os</code> es la encargada de leer los valores de las variables pedidas y puede asignarle un valor predefinido si la variable no existe.</p> <p>La URL se compone con ayuda de un f-string: <pre><code># ruta al servidor PostgreSQL\nruta = f\"postgresql://{user}:{password}@{dominio}:{puerto}/{database}\"\nprint(f\"URL de base de datos: {ruta}\")\n</code></pre></p> <p>Las variables de entorno implementadas son:</p> <ul> <li><code>PUERTO_POSTGRES</code></li> <li><code>DOMINIO_POSTGRES</code></li> <li><code>USUARIO_POSTGRES</code></li> <li><code>PASSW_POSTGRES</code></li> <li><code>DATABASE_POSTGRES</code></li> </ul>"},{"location":"componentes/venv/","title":"Entornos virtuales","text":"<p>En Python es habitual crear entornos virtuales, los cuales son r\u00e9plicas del int\u00e9rprete de Python  creadas normalmente adentro del directorio de cada proyecto. Cada entorno permite instalar paquetes de Python de manera independiente al int\u00e9rprete de Python principal. Esto ayuda a prevenir conflictos de dependencias entre los paquetes de distintos proyectos.</p>"},{"location":"componentes/venv/#modulo-venv","title":"M\u00f3dulo venv","text":"<p>Un modo habitual de crear un entorno virtual es el m\u00f3dulo venv, que viene integrado al int\u00e9rprete de Python.</p>"},{"location":"componentes/venv/#creacion","title":"Creaci\u00f3n","text":"<p>venv crea un directorio con los archivos de Python adentro:</p> <p><pre><code>py -m venv .venv\n</code></pre> La carpeta creada en este caso se llama <code>venv</code> y es oculta.</p>"},{"location":"componentes/venv/#activacion","title":"Activaci\u00f3n","text":"<p>La activaci\u00f3n del entorno virtual se realiza con el comando <code>source</code>.</p> Bash - LinuxBash - Windows <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>source .venv/Scripts/activate\n</code></pre> <p>Lo que hace el comando <code>source</code> es alterar la variable de entorno de Python <code>PYTHONPATH</code>, la cual es una lista de directorios donde se buscan los m\u00f3dulos y paquetes requeridos.  <code>source</code> coloca la ruta del entorno virtual al comienzo de la lista,  haciendo que el int\u00e9rprete del entorno virtual busque las dependencias en su propio directorio primero.</p> <p>La instalaci\u00f3n de los paquetes y el llamado al int\u00e9rprete se realiza de la manera habitual.</p>"},{"location":"componentes/venv/#desactivacion","title":"Desactivaci\u00f3n","text":"<p>El entorno virtual se desactiva con el comando <code>deactivate</code>:</p> <pre><code>deactivate\n</code></pre>"},{"location":"despliegue/","title":"Despliegue con contenedores","text":""},{"location":"despliegue/#introduccion-a-los-contenedores","title":"Introducci\u00f3n a los contenedores","text":"<p>Los contenedores son una herramienta para el despliegue de proyectos que permite una gran versatilidad.</p> <p>Uno de los puntos fuertes del uso de contenedores es la posibilidad de utilizar m\u00faltiples versiones de un mismo software al mismo tiempo, permitiendo un alto grado de control  por parte de los desarrolladores respecto a los componentes de software utilizados.</p> <p>Los contenedores trabajan en base a direcciones IPs y puertos para relacionarse unos con otros.</p>"},{"location":"despliegue/#gestores-y-orquestadores","title":"Gestores y Orquestadores","text":"<p>Tanto los programas gestores de contenedores como los programas orquestadores de contenedores permiten crear, configurar y controlar los contenedores. Sin embargo est\u00e1n pensados con distintos requisitos.</p> <p>Los gestores de contenedores tienen por objetivo el despliegue en un \u00fanico servidor, el cual puede ser un equipo local o puede ser tambi\u00e9n un servidor en internet.  El gestor de contenedores dominante es Docker, la cual es privativa y tiene la marca registrada. Una alternativa muy similar a Docker respecto al uso, sintaxis y recursos es Podman, el cual es soportado por RedHat y trata de cumplir con los requisitos de la Open Container Initiative (OCI). </p> <p>Por otra parte, los orquestadores tienen por prop\u00f3sito el despliegue en redes de servidores, los cuales son coordinados por el programa orquestador para crear y sostener los contenedores ,implementando mecanismos de confiabilidad y redundancia para asegurar una alta disponibilidad de los servicios. El orquestador m\u00e1s popular es Kubernetes, tambi\u00e9n llamado K8S, el cual fue desarrollado por Google.  \u00c9ste tiene varias alternativas reducidas como KinD, K3S, Minikube, etc.  Docker Compose y sus clones son considerados tambi\u00e9n como orquestadores pero con prestaciones reducidas, los cuales facilitan el despliegue por parte de los gestores de contenedores. </p>"},{"location":"despliegue/#elementos","title":"Elementos","text":"<p>El gestor de contenedores maneja varios tipos de elementos complementarios para poder realizar el despliegue de los proyectos. </p>"},{"location":"despliegue/#contenedores-containers","title":"Contenedores (<code>containers</code>)","text":"<p>Los contenedores son m\u00e1quinas virtuales hiper simplificadas, las cuales son desplegadas en un entorno controlado, aislados del sistema anfitri\u00f3n. </p>"},{"location":"despliegue/#imagenes-images","title":"Im\u00e1genes (<code>images</code>)","text":"<p>Las im\u00e1genes de los contenedores son los equivalentes a las im\u00e1genes de instalaci\u00f3n de los sistemas operativos. Son los \"sistemas operativos\" de los contenedores sobre los cuales se instalan los programas.</p>"},{"location":"despliegue/#capas-layers","title":"Capas (<code>layers</code>)","text":"<p>Los archivos de las im\u00e1genes se distribuyen en capas (layers), las cuales pueden ser reutilizadas por m\u00fatiples im\u00e1genes con el fin de reducir el espacio total ocupado en el almacenamiento. Las capas son controladas por el programa gestor/orquestador.</p>"},{"location":"despliegue/#volumenes-volumes","title":"Volumenes (<code>volumes</code>)","text":"<p>Los volumenes son almacenamientos persistentes a los que los contenedores pueden acceder. Son equivalentes a los almacenamientos extra\u00edbles de los equipos f\u00edsicos</p> <p>Los volumenes pueden ser rutas espec\u00edficas del sistema anfitri\u00f3n a la cual el gestor tiene acceso o pueden ser elementos abstractos creados en una carpeta especial por el programa gestor.</p>"},{"location":"despliegue/#redes-networks","title":"Redes (<code>networks</code>)","text":"<p>Las redes son elementos auxiliares que se usan para conectar a los contenedores entre s\u00ed en aquellos casos que sea necesario.</p> <p>Cada network equivale  a una red privada donde a cada contenedor con acceso tiene una IP privada que lo diferencia del resto. </p> <p>IPs clase A</p> <p>Las redes creadas t\u00edpicamente son clase A de ah\u00ed que la IP interna de cada contenedor tenga la forma 10.x.x.x </p>"},{"location":"despliegue/#opciones-y-herramientas","title":"Opciones y herramientas","text":"<p>Hay varias opciones y herramientas proporcionadas por los gestores de contenedores para trabajar con los contenedores.</p>"},{"location":"despliegue/#comandos","title":"Comandos","text":"<p>Los comandos son la forma m\u00e1s engorrosa de trabajar con contenedores y sus auxiliares, sin embargo son \u00fatiles para diagn\u00f3sticos, correcciones sobre la marcha,  etc.</p> <p>Los comandos se escriben desde la terminal.</p>"},{"location":"despliegue/#dockerfile","title":"Dockerfile","text":"<p>Los archivos <code>Dockerfile</code> son los archivos encargados de configurar la creaci\u00f3n de las im\u00e1genes necesarias para los contenedores, determinando la imagen de base,  instalando componentes necesarios,  copiando las rutinas,  etc.</p> <p>Estos archivos pueden ser ejecutados por comandos (<code>docker build</code>) o ser invocados indirectamente  desde el archivo <code>docker-compose.yml</code>.</p> <p>En los archivos <code>Dockerfile</code> siempre se asume que existe una imagen previa, con la cual se construye una nueva con m\u00e1s componentes.</p>"},{"location":"despliegue/#docker-compose","title":"Docker Compose","text":"<p>Los archivos <code>docker-compose.yml</code>  son archivos que facilitan configurar todos los par\u00e1metros de los contenedores del proyecto y sus elementos auxiliares en un archivo YAML, permitiendo el despliegue (deploy) con un s\u00f3lo comando en la terminal.</p> <p>Las secciones habituales de este archivo son:</p> <ul> <li><code>services</code>:  los servicios son los contenedores del proyecto, cada uno con sus par\u00e1metros, un nombre de 'servicio' y su IP interna;</li> <li><code>volumes</code>: volumenes del proyecto. y sus opciones</li> <li><code>networks</code>: redes usadas en el proyecto y sus configuraciones.</li> </ul> <p>Formato t\u00edpico: <pre><code>services:\n\n  servicio-1:\n    image: imagen-1\n\n\n  servicio-1:\n    image: imagen-2\n\n\nvolumes:\n  volumen-1:\n  volumen-2:\n    external: true\n\n\nnetworks:\n  red_1:\n</code></pre></p> <p>Nombre de servicio vs nombre de contenedor</p> <p>En el archivo Compose el nombre de servicio toma la apariencia de un alias para  el nombre de contenedor. Sin embargo, son dos atributos distintos:</p> <ul> <li> <p>El nombre del servicio equivale a un nombre de dominio con el cual puede ser consultado por otros servicios del proyecto mediante el protocolo IP.  </p> </li> <li> <p>El nombre del contenedor sirve para ser accedido desde el gestor de contenedores mediante la shell. Puede ser definido por el usuario mediante el atributo <code>container_name</code>.</p> </li> </ul> <p>Ejemplo:</p> <pre><code>services:\n\n    database:                       # nombre de servicio\n        image: postgres:latest\n        container_name: postgres-db # nombre de contenedor\n</code></pre>"},{"location":"despliegue/#compose","title":"Compose","text":"<p>Para realizar el despliegue autom\u00e1tico en Docker s\u00f3lo hay que ubicarse con la terminal en la carpeta  donde se ubica el archivo <code>docker-compose.yml</code> y ejecutar el comando <code>compose</code>:</p> <pre><code>docker compose up\n</code></pre> <p>Hay que esperar hasta que se complete la puesta en marcha, la cual puede requerir varios minutos la primera vez; mientras tanto, la shell ir\u00e1 mostrando los reportes del proceso. Docker descargar\u00e1 las im\u00e1genes faltantes de manera autom\u00e1tica y generar\u00e1 las im\u00e1genes derivadas a partir de los archivos <code>Dockerfile</code> cuyas rutas se indica en el archivo <code>docker-compose.yaml</code>. El funcionamiento se interrumpe con Ctrl+C.</p> <p>El despliegue independiente se consigue agregando la opci\u00f3n <code>-d</code>:</p> <pre><code>docker compose up -d\n</code></pre> <p>y para el cierre y eliminaci\u00f3n del despliegue actual se usa: <pre><code>docker compose down \n</code></pre></p> <p>Im\u00e1genes previas</p> <p>En caso de realizar modificaciones en el c\u00f3digo fuente, es prudente eliminar las im\u00e1genes creadas autom\u00e1ticamente con los archivos <code>Dockerfile</code> antes de invocar al comando <code>compose</code>. De otra manera, puede pasar que se sigan usando  las versiones antiguas de las im\u00e1genes creadas y  por ello el comportamiento del sistema no cambie nunca.</p>"},{"location":"despliegue/imagenes/","title":"Im\u00e1genes de Docker","text":"<p>En esta secci\u00f3n se discute qu\u00e9 posibles im\u00e1genes  pueden ser usados para el proyecto y se definen algunos criterios para la elecci\u00f3n de las mismas. </p> <p>Algunos criterios preliminares:</p> <ul> <li>Se busca en lo posible usar im\u00e1genes prearmadas oficiales de los frameworks y componentes elegidos;</li> <li>Si se necesita instalar los frameworks entonces se eligen las im\u00e1genes oficiales del lenguaje usado;</li> <li>Se deja como \u00faltima opci\u00f3n el uso de las im\u00e1genes base de los sistemas operativos.</li> </ul> <p>Tambi\u00e9n se enumeran algunas caracter\u00edsticas deseables:</p> <ul> <li>Bajo espacio en disco;</li> <li>Reutilizaci\u00f3n para varios componentes;</li> <li>Buena performance corriendo programas en Python cuando corresponda.</li> </ul>"},{"location":"despliegue/imagenes/#distribuciones-base","title":"Distribuciones base","text":"<p>Las im\u00e1genes de Docker se basan habitualmente en distribuciones GNU/Linux, las cuales son decapadas de los componentes innecesarios  (interfases gr\u00e1ficas, aplicaciones de usuario, etc) y son empaquetadas. Estas son las distribuciones m\u00e1s habituales  para crear im\u00e1genes en el presente:</p> Distribuci\u00f3n base Nombre clave Alpine <code>alpine</code> Debian 8 <code>jessie</code> Debian 9 <code>stretch</code> Debian 10 <code>buster</code> Debian 11 <code>bullseye</code> Debian 12 <code>bookworm</code> Ubuntu 16.04 <code>xenial</code> Ubuntu 18.04 <code>bionic</code> Ubuntu 20.04 <code>focal</code> Ubuntu 22.04 <code>jammy</code> Ubuntu 23.10 <code>mantic</code> Ubuntu 24.04 <code>noble</code> Windows Server <code>windowsservercore</code> <p>En general, es deseable usar en lo posible las im\u00e1genes basadas en las versiones m\u00e1s recientes de la distribuci\u00f3n base elegida.</p>"},{"location":"despliegue/imagenes/#shells-y-gestores-de-paquetes","title":"Shells y gestores de paquetes","text":"<p>Alpine usa el gestor de paquetes <code>apk</code> en tanto que Debian y Ubunto usan <code>apt</code>.</p> <p>Alpine tiene una shell interna en <code>/bin/sh</code>. Todas tienen una shell interna en <code>/bin/bash</code>.</p> <p>Esto es importante en caso que se necesite instalar componentes y bibiotecas para el sistema operativo.</p>"},{"location":"despliegue/imagenes/#versiones-slim","title":"Versiones slim","text":"<p>Las versiones slim son versiones \"rebajadas\" de las im\u00e1genes (documentacion eliminada, archivos extra quitados, etc) y tienen menos capas (layers) internas.  Gracias a ello estas versiones ocupan mucho menos espacio en disco  cuando est\u00e1n en solitario; sin embargo pueden ocupar m\u00e1s espacio en total que sus versiones completas cuando comparten disco con otras im\u00e1genes.</p>"},{"location":"despliegue/imagenes/#componentes-en-c","title":"Componentes en C","text":"<p>La mayor\u00eda de las distribuciones Linux, incluyendo Debian y Ubuntu, trabajan con <code>glibc</code> (GNU C library) y <code>coreutils</code> (GNU coreutils). En cambio, Alpine usa <code>musl libc</code> y <code>Busybox</code>. Esto hace que los lenguajes y programas que dependen de  componentes escritos en C (por ejemplo, el int\u00e9rprete oficial de Python)  funcionen diferente.</p>"},{"location":"despliegue/imagenes/#referencias","title":"Referencias","text":"<p>Medium.com - Alpine, Slim, Bullseye, Bookworm, Noble \u2014 Differences in Docker Images Explained</p> <p>StackOverflow - In Docker image names what is the difference between Alpine, Jessie, Stretch, and Buster?</p>"},{"location":"despliegue/postgres/","title":"PostgreSQL","text":"<p>PostgreSQL,  tambi\u00e9n llamado 'Postgres', es un sistema de administraci\u00f3n de bases de datos relacionales (ORDBMS) .</p>"},{"location":"despliegue/postgres/#imagenes-de-postgresql","title":"Im\u00e1genes de PostgreSQL","text":"<p>Postgres proporciona una lista de im\u00e1genes oficiales ya preparadas para su uso en contenedores. Estas est\u00e1n implementadas sobre im\u00e1genes tanto de Debian como de Alpine.</p>"},{"location":"despliegue/postgres/#variables-de-entorno","title":"Variables de entorno","text":"<p>Las configuraciones de las im\u00e1genes de gestores de bases de datos  se realizan mediante variables de entorno predefinidas. Las variables de entorno m\u00e1s importantes de PostgreSQL son las siguientes:</p> PostgreSQL - variables de entorno<pre><code>POSTGRES_PASSWORD   # contrase\u00f1a (OBLIGATORIA)\nPOSTGRES_USER       # usuario ('postgres' por default)\nPOSTGRES_DB         # nombre para nueva base de datos\n</code></pre> <p>Una forma experimental de cargar estos datos desde el archivo Compose  es bajo el atributo <code>environment</code>:</p> Compose - variables de entorno<pre><code># archivo 'docker-compose.yaml'\nservices:\n  postgres-test:\n    image: postgres\n    environment:\n      POSTGRES_PASSWORD:  \"123456\"\n      POSTGRES_USER:      \"postgres\"\n      POSTGRES_DB:        \"test-db\"\n</code></pre> <p>sin embargo los datos sensibles quedan expuestos. Una opci\u00f3n mejor es usar archivos de configuraci\u00f3n <code>.env</code> con el atributo <code>env_file</code>:</p> Compose - variables de entorno en archivo<pre><code># archivo 'docker-compose.yaml'\nservices:\n  postgres-test:\n    image: postgres\n    env_file: db.env\n</code></pre> <p>donde el archivo <code>db.env</code> trae guardadas las variables y sus valores:</p> <p>archivo 'db.env'<pre><code>POSTGRES_PASSWORD=123456\nPOSTGRES_USER=postgres\nPOSTGRES_DB=test-db\n</code></pre> Una segunda alternativa es el uso de los \"secrets\" de Docker.</p>"},{"location":"despliegue/postgres/#puertos","title":"Puertos","text":"<p>La imagen de PostgreSQL usa el puerto 5432 para las conexiones con los clientes. Los sockets usados por Posgres son siempre del tipo TCP.</p> <p>Para hacer el 'mapeo' de puertos a un puerto distinto del sistema anfitri\u00f3n, desde el archivo Compose se hace:</p> <p><pre><code># archivo 'docker-compose.yaml'\nservices:\n  postgres-test:\n    image: postgres\n    ports:\n      - '9000:5432'\n</code></pre> en este ejemplo se expone el puerto 9000 para que Postgres pueda ser consultado desde el sistema anfitri\u00f3n. Los otros contenedores pueden consultar mediante el puerto predefinido.</p>"},{"location":"despliegue/postgres/#volumenes","title":"Volumenes","text":"<p>Los gestores de contenedores borran toda la data interna de los contenedores cada vez que los cierran. Debido a la naturaleza persistente de las bases de datos, es indispensable crear vol\u00famenes (almacenamientos persistentes) para que el ORM le asigne los datos adentro y as\u00ed estos no se pierdan.</p> <p>Las im\u00e1genes de Postgres  guardan las bases de datos en la ruta interna <code>/var/lib/postgresql/data</code>. Esta ruta debe ser asignada a un volumen para que se resguarde la base de datos correctamente.</p> <p>En el caso crear los contenedores con archivos compose se crea un volumen en la secci\u00f3n <code>volumes</code> y se le asigna la ruta de la imagen dentro de la definici\u00f3n del contenedor:</p> <pre><code># archivo 'docker-compose.yaml'\nservices:\n  postgres-test:\n    image: postgres\n    volumes:\n      - 'volumen-db:/var/lib/postgresql/data'  # montaje volumen\n\nvolumes:   \n  volumen-db:       # creaci\u00f3n volumen\n</code></pre> <p>Si se busca que el volumen sea externo,  es decir que \u00e9ste debe ser creado deliberadamente por el desarrollador, se a\u00f1ade la opci\u00f3n <code>external</code> en la definici\u00f3n:</p> <pre><code># archivo 'docker-compose.yaml'\nvolumes:   \n  volumen-db:       # creaci\u00f3n volumen\n    external: true  # debe ser preexistente\n</code></pre> <p>Volumenes - Creacion manual</p> <p>Los vol\u00famenes se crean manualmente con Docker mediante la terminal:</p> <pre><code>docker volume create  nombre_volumen\n</code></pre> <p>Y la ubicac\u00ed\u00f3n de su informaci\u00f3n guardada aparecer\u00e1 en la ruta del sistema anfitri\u00f3n indicada por:</p> <p><pre><code>docker volume inspect --format {{.Mountpoint}}  nombre_volumen\n</code></pre> Rutas habituales:</p> WindowsGNU/Linux <pre><code>???\n</code></pre> <pre><code>/home/USUARIO/.local/share/containers/storage/volumes/volumen_exterior/_data\n</code></pre>"},{"location":"despliegue/postgres/#referencias","title":"Referencias","text":"<p>Docker Hub - Postgres</p> <p>DelfStack - Puerto predeterminado de PostgreSQL</p> <p>Docker Docs - Volumes</p>"},{"location":"despliegue/pruebas/","title":"Despliegue local","text":""},{"location":"despliegue/pruebas/#demo","title":"Demo","text":"<p>Como primer acercamiento a la integraci\u00f3n y despliegue del proyecto se hizo una carpeta <code>tests</code> donde se organizan todos los componentes de ejemplo.</p> <p>La estructura interna es aproximadamente la siguiente:</p> Demo - estructura<pre><code>tests\n\u251c\u2500\u2500 db.env\n\u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 fastapi\n\u2502   \u251c\u2500\u2500 app\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 main.py\n\u2502   \u251c\u2500\u2500 docker-compose.yml\n\u2502   \u251c\u2500\u2500 Dockerfile\n\u2502   \u2514\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 flet\n\u2502   \u251c\u2500\u2500 Dockerfile\n\u2502   \u251c\u2500\u2500 pyproject.toml\n\u2502   \u251c\u2500\u2500 requirements.txt\n\u2502   \u2514\u2500\u2500 src\n\u2502       \u251c\u2500\u2500 assets\n\u2502       \u2514\u2500\u2500 main.py\n\u2514\u2500\u2500 sqlmodel\n    \u251c\u2500\u2500 Dockerfile\n    \u251c\u2500\u2500 requirements.txt\n    \u2514\u2500\u2500 src\n        \u2514\u2500\u2500 main.py\n</code></pre> <ul> <li> <p>Para correr las pruebas preliminares en Docker se cre\u00f3 el archivo <code>docker-compose.yml</code>, el cual se encuentra en la carpeta <code>tests</code>. Este archivo ya incluye todas las configuraciones predefinidas  para el despliegue de los contenedores.</p> </li> <li> <p>El archivo <code>db.env</code> es el encargado de guardar los valores de configuraci\u00f3n.</p> </li> <li> <p>Cada framework o componente de Python utilizado tiene su propia carpeta interna, incluyendo:</p> <ul> <li>su rutina de demo <code>main.py</code>;</li> <li>su archivo de dependencias <code>requirements.txt</code>;</li> <li>su archivo <code>Dockerfile</code> para que Docker pueda crear las im\u00e1genes necesarias.</li> </ul> <p>Tambi\u00e9n es posible desplegar los componentes del demo mediante entornos virtuales usando m\u00faltiples shells, aunque este m\u00e9todo es el m\u00e1s engorroso.</p> </li> </ul>"},{"location":"despliegue/pruebas/#funcionamiento","title":"Funcionamiento","text":""},{"location":"despliegue/pruebas/#conexiones-por-navegador","title":"Conexiones por navegador","text":"<p>Una vez completada la puesta en marcha, se abre el navegador y se prueba ingresar a la ruta local  (<code>localhost</code> o <code>127.0.0.1</code>) agregando los n\u00fameros de puerto especificados.</p>"},{"location":"despliegue/pruebas/#backend","title":"Backend","text":"<p>En el caso del backend se eligi\u00f3 el puerto 9001. Los demos se ven con las siguientes URLs:</p> <p><pre><code>http://localhost:9001/\nhttp://localhost:9001/items/25\n</code></pre> El resultado es un objeto JSON (un \"diccionario\" de Python)</p> <p>La documentaci\u00f3n generada por FastAPI se consulta en las rutas:</p> <pre><code>http://localhost:9001/docs\nhttp://localhost:9001/redocs\n</code></pre>"},{"location":"despliegue/pruebas/#frontend","title":"Frontend","text":"<p>Para el frontend se eligi\u00f3 el puerto 9002: <pre><code>http://localhost:9002/\n</code></pre> El demo es un contador sencillo que se incrementa al hacer click sobre el bot\u00f3n.</p>"},{"location":"despliegue/pruebas/#documentacion-local","title":"Documentaci\u00f3n (local)","text":"<p>La documentaci\u00f3n se consulta en el puerto 9003: <pre><code>http://localhost:9003/\n</code></pre></p> <p>dando lugar a la presente documentaci\u00f3n. Los archivos de texto y de configuraci\u00f3n est\u00e1n afuera del directorio del test, porque son relevantes para todo el proyecto.</p>"},{"location":"despliegue/pruebas/#bases-de-datos","title":"Bases de datos","text":"<p>De momento, la \u00fanica base de datos utiliza el puerto 9000. Se usa un cliente para base de datos y se crea una conexi\u00f3n para base de datos con los siguientes par\u00e1metros:</p> variable valor nombre de driver PostgreSQL puerto <code>9000</code> usuario <code>postgres</code> contrase\u00f1a <code>123456</code> nombre database <code>test-db</code> <p>El cliente deber\u00eda ser capaz de conectarse y mostrar las bases de datos internas <code>postgres</code> (se crea por default) y <code>test-db</code>.</p>"},{"location":"despliegue/pruebas/#cliente-de-base-de-datos","title":"Cliente de base de datos","text":"<p>Se implement\u00f3 un cliente que hace una \u00fanica petici\u00f3n a la base de datos y se detiene. La petici\u00f3n consiste en crear una tabla llamada <code>hero</code> y agregarle tres filas de datos. Si la tabla ya existe entonces se repiten las filas de datos.</p>"},{"location":"despliegue/python/","title":"Python","text":""},{"location":"despliegue/python/#imagenes-de-python","title":"Im\u00e1genes de Python","text":"<p>El lenguaje Python dispone de una  gran cantidad de im\u00e1genes disponibles listas para su uso.</p> <p>La versi\u00f3n de Python m\u00e1s reciente disponible es la 3.14 .</p>"},{"location":"despliegue/python/#imagenes-estandar","title":"Im\u00e1genes est\u00e1ndar","text":"<p>Las im\u00e1genes de Python est\u00e1ndar est\u00e1n basadas en Debian. Estas im\u00e1genes son las m\u00e1s compatibles para trabajar con todo tipo de programas. Pesan alrededor de 1GB.</p>"},{"location":"despliegue/python/#alpine-es-problematico-para-trabajar-con-python","title":"Alpine es problem\u00e1tico para trabajar con Python","text":"<p>Las im\u00e1genes basadas en Alpine tienen varias desventajas al correr programas escritos en Python:</p> <ul> <li>Tiempos de instalaci\u00f3n exageradamente largos;</li> <li>Im\u00e1genes creadas m\u00e1s voluminosas,  a\u00fan eliminando cach\u00e9 interna;</li> <li> <p>La mayoria de los desarrolladores de Python no cumplen las dependencias del programa con los paquetes del sistema sino que usan los paquetes de PyPi o Conda Forge.</p> </li> <li> <p>Bugs inesperados:</p> <ul> <li><code>msl</code> no soporta DNS sobre TCP, lo cual puede hacer fallar la configuraci\u00f3n de Kubernetes;</li> <li>Pila m\u00e1s chica para los hilos, que pueden hacer crashear a Python;</li> <li>Reserva de memoria din\u00e1mica mucho m\u00e1s lenta.</li> </ul> </li> </ul> <p>Por este motivo, se prefiere evitar usar las im\u00e1genes basadas en Alpine para los programas escritos en Python. </p>"},{"location":"despliegue/python/#versiones-slim","title":"Versiones <code>slim</code>","text":"<p>Las im\u00e1genes de Python basadas en Debian tienen sus versiones est\u00e1ndar y sus contrapartes slim. De \u00e9stas, las im\u00e1genes est\u00e1ndar pesan alrededor de 1GB  en tanto que sus versiones slim pesan apenas poco m\u00e1s de 100MB.</p> <p>Sin embargo, se advierte que las im\u00e1genes slim pueden traer conflictos al intentar instalar ciertos paquetes debido a la falta de algunos componentes del sistema.</p>"},{"location":"despliegue/python/#windows-server-core","title":"Windows Server Core","text":"<p>Estas im\u00e1genes est\u00e1n basadas en Windows Server. Est\u00e1n pensadas para su uso para programas que requieran correr .NET u otros componentes exclusivos de Windows.</p>"},{"location":"despliegue/python/#referencias","title":"Referencias","text":"<p>Docker Hub - Python</p> <p>Python Speed - Using Alpine can make Python Docker builds 50\u00d7 slower</p>"},{"location":"despliegue/sqlmodel/","title":"SQLModel","text":""},{"location":"despliegue/sqlmodel/#backend-vs-demo","title":"Backend vs demo","text":"<p>SQLModel trabaja como parte del backend, por ello ser\u00e1 integrado junto a las rutinas de FastAPI y por tanto compartir\u00e1 contenedor con \u00e9l.</p> <p>Como contrapartida, en el caso del demo SQLModel se instala en solitario. Esto es as\u00ed porque en la rutina de demo s\u00f3lo se desea probar la conectividad de la rutina entre contenedores.</p>"},{"location":"despliegue/sqlmodel/#compose","title":"Compose","text":""},{"location":"despliegue/sqlmodel/#puertos","title":"Puertos","text":"<p>Este contenedor no expone ning\u00fan puerto. S</p>"},{"location":"despliegue/sqlmodel/#variables-de-entorno","title":"Variables de entorno","text":"<p>El contenedor necesita los valores de ciertas variables de entorno para poder crear la URL necesaria para consultar a la base de datos.</p> <p>Las variables de entorno se parten en dos grupos:</p> <ul> <li> <p>Los datos de sesi\u00f3n (usuario, contrase\u00f1as) se guardan en un archivo <code>.env</code> que es especificado desde el archivo Compose.     Variables incluidas:</p> <ul> <li><code>USUARIO_POSTGRES</code></li> <li><code>PASSW_POSTGRES</code></li> <li><code>DATABASE_POSTGRES</code></li> </ul> </li> <li> <p>Los par\u00e1metros de la IP y el puerto de conexi\u00f3n se indican en el archivo Compose directamente:</p> <ul> <li><code>PUERTO_POSTGRES</code></li> <li><code>DOMINIO_POSTGRES</code></li> </ul> </li> </ul>"}]}